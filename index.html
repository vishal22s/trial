<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PDF Page Splitter & Imposer — 16-up with per-mini-page watermark</title>

<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>

<style>
    :root{
        --primary:#007bff; --secondary:#6c757d; --bg:#f8f9fa; --card:#fff;
        --text:#212529; --border:#dee2e6; --success:#28a745;
    }
    body{font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial; background:var(--bg); color:var(--text); margin:0; padding:20px; display:flex; justify-content:center;}
    .container{max-width:900px;width:100%;background:var(--card);padding:28px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.08);}
    h1{color:var(--primary); text-align:center; margin:0 0 8px;}
    p.desc{color:var(--secondary); text-align:center; margin:0 0 20px;}
    .section{margin-bottom:18px;padding:16px;border:1px solid var(--border);border-radius:6px;}
    .upload-area{display:block;text-align:center;border:2px dashed var(--border);padding:36px;border-radius:6px;cursor:pointer;}
    .upload-area:hover{background:#eef2f6;border-color:var(--primary);}
    #pdf-upload{display:none;}
    #file-name{margin-top:12px;font-weight:600;color:var(--primary);}
    details{border:1px solid var(--border);border-radius:6px;padding:10px;}
    summary{font-weight:700;color:var(--primary);cursor:pointer;}
    .watermark-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:12px;}
    .control-group{display:flex;flex-direction:column;}
    .control-group label{margin-bottom:6px;font-size:.9rem;color:var(--secondary);}
    input[type="text"], input[type="color"], select{padding:8px;border-radius:6px;border:1px solid var(--border);width:100%;}
    .btn{display:block;width:100%;padding:12px;font-weight:700;color:#fff;background:var(--primary);border:none;border-radius:6px;cursor:pointer;}
    .btn:disabled{background:var(--secondary);cursor:not-allowed;}
    #progress-container{text-align:center;margin-top:16px;}
    #output-container{display:none;grid-template-columns:1fr 1fr;gap:18px;margin-top:18px;}
    .output-box{text-align:center;}
    .output-box canvas{border:1px solid var(--border);max-width:400px;width:100%;height:auto;}
    .download-btn{display:inline-block;margin-top:12px;padding:10px 16px;background:var(--success);color:#fff;border-radius:6px;text-decoration:none;}
    .hidden{display:none;}
</style>
</head>
<body>
<div class="container">
    <h1>PDF Page Splitter & Imposer</h1>
    <p class="desc">Uploads a PDF, splits into odd/even, places 16 mini-pages per A4, and adds per-mini-page watermark + page number.</p>

    <div class="section">
        <label class="upload-area" for="pdf-upload">
            <div>Click to select PDF (or drag & drop if you add that later)</div>
            <p id="file-name">No file selected</p>
        </label>
        <input id="pdf-upload" type="file" accept="application/pdf">
    </div>

    <div class="section">
        <details>
            <summary>Watermark Options (Optional)</summary>
            <div style="margin-top:12px;display:flex;align-items:center;gap:10px;">
                <input id="watermark-enabled" type="checkbox">
                <label for="watermark-enabled">Enable Watermark</label>
            </div>
            <fieldset id="watermark-options" disabled style="margin-top:12px;border:none;padding:0;">
                <div class="watermark-grid">
                    <div class="control-group">
                        <label for="watermark-text">Text</label>
                        <input id="watermark-text" type="text" value="">
                    </div>
                    <div class="control-group">
                        <label for="watermark-position">Position</label>
                        <select id="watermark-position">
                            <option value="center">Center</option>
                            <option value="top-left">Top-Left</option>
                            <option value="top-right">Top-Right</option>
                            <option value="bottom-left">Bottom-Left</option>
                            <option value="bottom-right">Bottom-Right</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="watermark-opacity">Opacity (<span id="opacity-value">0.5</span>)</label>
                        <input id="watermark-opacity" type="range" min="0" max="1" step="0.05" value="0.5">
                    </div>
                    <div class="control-group">
                        <label for="watermark-size">Font Size (<span id="size-value">50</span>pt)</label>
                        <input id="watermark-size" type="range" min="8" max="150" step="1" value="50">
                    </div>
                    <div class="control-group">
                        <label for="watermark-rotation">Rotation (<span id="rotation-value">45</span>°)</label>
                        <input id="watermark-rotation" type="range" min="-90" max="90" step="5" value="45">
                    </div>
                    <div class="control-group">
                        <label for="watermark-color">Color</label>
                        <input id="watermark-color" type="color" value="#ff0000">
                    </div>
                </div>
            </fieldset>
        </details>
    </div>

    <button id="process-btn" class="btn" disabled>Process PDF</button>

    <div id="progress-container" class="hidden">
        <p id="progress-text">Processing...</p>
    </div>

    <div id="output-container">
        <div class="output-box">
            <h3>Odd Pages Output</h3>
            <canvas id="odd-preview"></canvas>
            <a id="download-odd-link" class="download-btn hidden" download>Download Odd PDF</a>
        </div>
        <div class="output-box">
            <h3>Even Pages Output</h3>
            <canvas id="even-preview"></canvas>
            <a id="download-even-link" class="download-btn hidden" download>Download Even PDF</a>
        </div>
    </div>
</div>

<script>
/* Setup PDF.js worker */
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js';

/* DOM refs */
const pdfUpload = document.getElementById('pdf-upload');
const fileNameDisplay = document.getElementById('file-name');
const processBtn = document.getElementById('process-btn');
const progressContainer = document.getElementById('progress-container');
const progressText = document.getElementById('progress-text');
const outputContainer = document.getElementById('output-container');

const wmEnabled = document.getElementById('watermark-enabled');
const wmOptions = document.getElementById('watermark-options');
const wmText = document.getElementById('watermark-text');
const wmPosition = document.getElementById('watermark-position');
const wmOpacity = document.getElementById('watermark-opacity');
const wmSize = document.getElementById('watermark-size');
const wmRotation = document.getElementById('watermark-rotation');
const wmColor = document.getElementById('watermark-color');
const opacityValue = document.getElementById('opacity-value');
const sizeValue = document.getElementById('size-value');
const rotationValue = document.getElementById('rotation-value');

const oddCanvas = document.getElementById('odd-preview');
const evenCanvas = document.getElementById('even-preview');
const downloadOddLink = document.getElementById('download-odd-link');
const downloadEvenLink = document.getElementById('download-even-link');

let selectedFile = null;

/* Events */
pdfUpload.addEventListener('change', (e) => {
    selectedFile = e.target.files[0];
    if (selectedFile) {
        fileNameDisplay.textContent = selectedFile.name;
        processBtn.disabled = false;
    } else {
        fileNameDisplay.textContent = 'No file selected';
        processBtn.disabled = true;
    }
});

wmEnabled.addEventListener('change', () => {
    wmOptions.disabled = !wmEnabled.checked;
});

wmOpacity.addEventListener('input', () => opacityValue.textContent = wmOpacity.value);
wmSize.addEventListener('input', () => sizeValue.textContent = wmSize.value);
wmRotation.addEventListener('input', () => rotationValue.textContent = wmRotation.value);

processBtn.addEventListener('click', processPDF);

/* Main processing */
async function processPDF() {
    if (!selectedFile) { alert('Please select a PDF file first.'); return; }

    processBtn.disabled = true;
    progressContainer.classList.remove('hidden');
    outputContainer.style.display = 'none';
    downloadOddLink.classList.add('hidden'); downloadEvenLink.classList.add('hidden');
    progressText.textContent = 'Reading file...';

    try {
        const fileBuffer = await selectedFile.arrayBuffer();
        // Keep a Uint8Array copy to pass into embedPdf
        const originalBytes = new Uint8Array(fileBuffer);

        const { PDFDocument } = PDFLib;
        progressText.textContent = 'Loading source PDF...';
        const originalPdf = await PDFDocument.load(fileBuffer);
        const pageCount = originalPdf.getPageCount();

        // build odd/even index lists (0-based)
        const oddPageIndices = [], evenPageIndices = [];
        for (let i = 0; i < pageCount; i++) {
            if ((i + 1) % 2 !== 0) oddPageIndices.push(i);
            else evenPageIndices.push(i);
        }

        // Build watermark options (NO font object here — font must be embedded into each output PDF)
        let watermarkOptions = null;
        if (wmEnabled.checked) {
            const hex = wmColor.value;
            watermarkOptions = {
                text: (wmText.value || '').trim(),
                position: wmPosition.value || 'center',
                opacity: parseFloat(wmOpacity.value),
                size: parseInt(wmSize.value, 10),
                rotation: parseInt(wmRotation.value, 10), // degrees (number)
                color: {
                    r: parseInt(hex.slice(1,3),16) / 255,
                    g: parseInt(hex.slice(3,5),16) / 255,
                    b: parseInt(hex.slice(5,7),16) / 255
                }
            };
        }

        // create both PDFs (each returns a PDFDocument instance)
        progressText.textContent = 'Imposing odd pages...';
        const oddOutputPdf = await createImposedPdf(originalBytes, oddPageIndices, 'odd', (t)=>progressText.textContent=t, watermarkOptions);
        progressText.textContent = 'Imposing even pages...';
        const evenOutputPdf = await createImposedPdf(originalBytes, evenPageIndices, 'even', (t)=>progressText.textContent=t, watermarkOptions);

        // finalize and create downloads
        progressText.textContent = 'Finalizing files...';
        const oddPdfBytes = await oddOutputPdf.save();
        const evenPdfBytes = await evenOutputPdf.save();

        setupDownload(downloadOddLink, oddPdfBytes, `${selectedFile.name.replace(/\.pdf$/i,'')}_odd.pdf`);
        setupDownload(downloadEvenLink, evenPdfBytes, `${selectedFile.name.replace(/\.pdf$/i,'')}_even.pdf`);

        await renderPreview(oddPdfBytes, oddCanvas);
        await renderPreview(evenPdfBytes, evenCanvas);

        outputContainer.style.display = 'grid';
        progressText.textContent = 'Processing complete!';
    } catch (err) {
        console.error('Processing error:', err);
        progressText.textContent = `Error: ${err.message || err}`;
        alert(`An error occurred: ${err.message || err}`);
    } finally {
        processBtn.disabled = false;
    }
}

/**
 * Create a new imposed PDF containing up to 16 mini-pages per A4 sheet.
 * - originalBytes: Uint8Array of source PDF bytes
 * - pageIndices: array of 0-based page indices from source to include
 * - type: 'odd' or 'even' (affects left-to-right vs right-to-left placement)
 * - updateProgress: function(text)
 * - watermarkOptions: {text,position,opacity,size,rotation,color} or null
 */
async function createImposedPdf(originalBytes, pageIndices, type, updateProgress, watermarkOptions) {
    const { PDFDocument } = PDFLib;
    const outputPdf = await PDFDocument.create();

    if (!pageIndices || pageIndices.length === 0) return outputPdf;

    const numSheets = Math.ceil(pageIndices.length / 16);
    const A4_WIDTH = 595, A4_HEIGHT = 842; // points
    const cellCols = 4, cellRows = 4;
    const cellWidth = A4_WIDTH / cellCols;
    const cellHeight = A4_HEIGHT / cellRows;

    // If watermark requested, embed a font into this output PDF (fonts must belong to the PDF where used)
    let embeddedFont = null;
    if (watermarkOptions) {
        embeddedFont = await outputPdf.embedFont(PDFLib.StandardFonts.HelveticaBold);
    }

    for (let s = 0; s < numSheets; s++) {
        updateProgress(`Building ${type} layout (${s+1}/${numSheets})...`);
        const targetPage = outputPdf.addPage([A4_WIDTH, A4_HEIGHT]);

        const pageChunk = pageIndices.slice(s * 16, (s + 1) * 16);
        // embed pages from the original bytes into this output PDF
        const embeddedPages = await outputPdf.embedPdf(originalBytes, pageChunk);

        for (let i = 0; i < embeddedPages.length; i++) {
            const embeddedPage = embeddedPages[i];

            // grid position: compute row, col; even pages use rtl per-row
            const row = Math.floor(i / cellCols);
            const col = (type === 'odd') ? (i % cellCols) : (cellCols - 1 - (i % cellCols));

            // compute top-left of this cell
            const cellX = col * cellWidth;
            const cellY = A4_HEIGHT - (row + 1) * cellHeight;

            // preserve original page aspect ratio while fitting into cell
            const eW = embeddedPage.width;
            const eH = embeddedPage.height;
            const scale = Math.min(cellWidth / eW, cellHeight / eH);
            const drawW = eW * scale;
            const drawH = eH * scale;

            // center embedded mini-page within the cell
            const drawX = cellX + (cellWidth - drawW) / 2;
            const drawY = cellY + (cellHeight - drawH) / 2;

            targetPage.drawPage(embeddedPage, { x: drawX, y: drawY, width: drawW, height: drawH });

            // per-mini-page watermark (if enabled)
            if (watermarkOptions && embeddedFont) {
                const originalPageNumber = pageChunk[i] + 1; // convert 0-based index to 1-based
                const miniText = `${watermarkOptions.text} ${originalPageNumber}`;

                // choose font size relative to mini-page height to prevent overflow
                const desiredSize = watermarkOptions.size || 50;
                const maxSize = Math.max(6, Math.floor(drawH * 0.35)); // cap to 35% of mini-page height
                const fontSize = Math.min(desiredSize, maxSize);

                // calculate text metrics (width; height approximate fontSize)
                let textWidth = 0;
                try { textWidth = embeddedFont.widthOfTextAtSize(miniText, fontSize); } catch (e) { textWidth = miniText.length * fontSize * 0.5; }
                const textHeight = fontSize; // approximate

                // position according to selected option, inside the mini-page area
                let wx, wy;
                switch (watermarkOptions.position) {
                    case 'top-left':
                        wx = drawX + 5;
                        wy = drawY + drawH - textHeight - 5;
                        break;
                    case 'top-right':
                        wx = drawX + drawW - textWidth - 5;
                        wy = drawY + drawH - textHeight - 5;
                        break;
                    case 'bottom-left':
                        wx = drawX + 5;
                        wy = drawY + 5;
                        break;
                    case 'bottom-right':
                        wx = drawX + drawW - textWidth - 5;
                        wy = drawY + 5;
                        break;
                    case 'center':
                    default:
                        wx = drawX + (drawW - textWidth) / 2;
                        wy = drawY + (drawH - textHeight) / 2;
                        break;
                }

                // clamp to cell bounds to avoid negative coords
                if (wx < drawX + 2) wx = drawX + 2;
                if (wy < drawY + 2) wy = drawY + 2;

                // color
                const color = PDFLib.rgb(watermarkOptions.color.r, watermarkOptions.color.g, watermarkOptions.color.b);

                // draw the text (rotation is applied about its bottom-left corner — it's visually OK for watermark)
                targetPage.drawText(miniText, {
                    x: wx,
                    y: wy,
                    size: fontSize,
                    font: embeddedFont,
                    color,
                    opacity: watermarkOptions.opacity,
                    rotate: PDFLib.degrees(watermarkOptions.rotation)
                });
            }
        }
    }

    return outputPdf;
}

/* Helpers */
function setupDownload(linkElement, bytes, filename) {
    const blob = new Blob([bytes], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    linkElement.href = url;
    linkElement.download = filename;
    linkElement.classList.remove('hidden');
}

async function renderPreview(pdfBytes, canvasElement) {
    // pdfBytes might be Uint8Array; pdfjs accepts it
    const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
    const pdf = await loadingTask.promise;
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 1.2 });
    canvasElement.height = viewport.height;
    canvasElement.width = viewport.width;
    const ctx = canvasElement.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
}
</script>
</body>
</html>