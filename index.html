<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PDF 16-up Imposer — per-mini-page watermark modes</title>

<!-- Known-working libraries -->
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>

<style>
  :root{
    --primary:#0d6efd; --muted:#6c757d; --bg:#f8f9fa; --card:#fff; --border:#e6e6e6;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); margin:20px; color:#111;}
  .wrap{max-width:980px;margin:0 auto;background:var(--card);padding:22px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.06);}
  h1{color:var(--primary);margin:0 0 6px;}
  p.lead{color:var(--muted);margin:0 0 18px;}
  .row{display:flex;gap:12px;flex-wrap:wrap;}
  .card{background:#fff;border:1px solid var(--border);padding:14px;border-radius:8px;flex:1 1 300px;min-width:260px}
  label{display:block;font-size:0.9rem;margin-bottom:6px;color:var(--muted)}
  input[type="file"]{display:none}
  .upload{border:2px dashed var(--border);padding:20px;text-align:center;border-radius:8px;cursor:pointer}
  .upload:hover{background:#fbfdff}
  .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  select,input[type="text"],textarea{width:100%;padding:8px;border-radius:6px;border:1px solid var(--border)}
  textarea{min-height:120px;font-family:monospace}
  .btn{display:inline-block;padding:10px 14px;border-radius:8px;background:var(--primary);color:#fff;border:none;cursor:pointer;font-weight:700}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .small{font-size:0.85rem;color:var(--muted)}
  #output{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:18px}
  canvas{width:100%;max-width:420px;border:1px solid var(--border);background:#fff}
  .download{display:inline-block;margin-top:8px;padding:8px 10px;background:#198754;color:#fff;border-radius:6px;text-decoration:none}
  .hidden{display:none}
  .notice{font-size:0.85rem;color:#b03a2e}
</style>
</head>
<body>
<div class="wrap">
  <h1>PDF 16-up Imposer</h1>
  <p class="lead">Split PDF into odd/even sets, impose 16 mini-pages per A4 sheet and add per-mini-page watermark. Use Page Numbers or Custom text (same/different).</p>

  <div class="row">
    <div class="card">
      <label for="file">Upload PDF</label>
      <label class="upload" id="uploadLabel">Click to select PDF
        <input id="file" type="file" accept="application/pdf">
      </label>
      <div class="small" id="fileName">No file selected</div>

      <hr style="margin:12px 0">

      <label>Watermark Mode</label>
      <select id="wmMode">
        <option value="pageNumbers">Page Numbers (clean)</option>
        <option value="customSame">Custom Text — Same for all mini-pages</option>
        <option value="customDifferent">Custom Text — Different per original page</option>
      </select>

      <div id="sameBox" class="hidden" style="margin-top:10px;">
        <label>Custom text (applied to all mini-pages)</label>
        <input id="customSame" type="text" placeholder="e.g. CONFIDENTIAL">
      </div>

      <div id="differentBox" class="hidden" style="margin-top:10px;">
        <label>Custom texts (one line = original page #1, line2 = page #2...)</label>
        <textarea id="customDifferent" placeholder="Line 1 -> original page 1&#10;Line 2 -> original page 2"></textarea>
        <div class="small">If you enter fewer lines than pages, remaining pages will have no custom text.</div>
      </div>

      <hr style="margin:12px 0">

      <label>Appearance</label>
      <div class="controls">
        <div>
          <label>Position</label>
          <select id="wmPos">
            <option value="center">Center</option>
            <option value="top-left">Top-left</option>
            <option value="top-right">Top-right</option>
            <option value="bottom-left">Bottom-left</option>
            <option value="bottom-right">Bottom-right</option>
          </select>
        </div>
        <div>
          <label>Rotation (deg)</label>
          <input type="range" id="wmRot" min="-90" max="90" value="0">
          <div class="small">Rotation: <span id="rotVal">0</span>°</div>
        </div>

        <div>
          <label>Opacity</label>
          <input type="range" id="wmOpacity" min="0" max="1" step="0.05" value="0.45">
          <div class="small">Opacity: <span id="opVal">0.45</span></div>
        </div>

        <div>
          <label>Base font size (pt)</label>
          <input type="range" id="wmSize" min="8" max="80" value="28">
          <div class="small">Size: <span id="sizeVal">28</span>pt</div>
        </div>

        <div>
          <label>Color</label>
          <input type="color" id="wmColor" value="#b22222">
        </div>

        <div>
          <label>&nbsp;</label>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn" id="processBtn" disabled>Process PDF</button>
            <div class="small" id="progress" style="margin-left:8px"></div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="notice">Tip: For "Different per original page", provide exact mapping lines starting from original page 1.</div>
      </div>
    </div>

    <div class="card">
      <label>Preview & Downloads</label>
      <div id="output" style="min-height:280px;align-items:start">
        <div>
          <h4 style="margin:6px 0">Odd Pages</h4>
          <canvas id="oddPreview"></canvas><br>
          <a id="oddDownload" class="download hidden">Download Odd PDF</a>
        </div>
        <div>
          <h4 style="margin:6px 0">Even Pages</h4>
          <canvas id="evenPreview"></canvas><br>
          <a id="evenDownload" class="download hidden">Download Even PDF</a>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* worker */
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js';

/* DOM */
const fileInput = document.getElementById('file');
const uploadLabel = document.getElementById('uploadLabel');
const fileName = document.getElementById('fileName');
const processBtn = document.getElementById('processBtn');
const progressEl = document.getElementById('progress');

const wmMode = document.getElementById('wmMode');
const sameBox = document.getElementById('sameBox');
const differentBox = document.getElementById('differentBox');
const customSame = document.getElementById('customSame');
const customDifferent = document.getElementById('customDifferent');

const wmPos = document.getElementById('wmPos');
const wmRot = document.getElementById('wmRot');
const rotVal = document.getElementById('rotVal');
const wmOpacity = document.getElementById('wmOpacity');
const opVal = document.getElementById('opVal');
const wmSize = document.getElementById('wmSize');
const sizeVal = document.getElementById('sizeVal');
const wmColor = document.getElementById('wmColor');

const oddPreview = document.getElementById('oddPreview');
const evenPreview = document.getElementById('evenPreview');
const oddDownload = document.getElementById('oddDownload');
const evenDownload = document.getElementById('evenDownload');

let selectedBytes = null;
let originalPageCount = 0;

/* UI interactions */
fileInput.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) { fileName.textContent='No file selected'; processBtn.disabled = true; return; }
  fileName.textContent = f.name;
  processBtn.disabled = false;
  selectedBytes = new Uint8Array(await f.arrayBuffer());

  // get page count for helper display
  const srcDoc = await PDFLib.PDFDocument.load(selectedBytes);
  originalPageCount = srcDoc.getPageCount();
});

uploadLabel.addEventListener('click', () => fileInput.click());

wmMode.addEventListener('change', () => {
  sameBox.classList.toggle('hidden', wmMode.value !== 'customSame');
  differentBox.classList.toggle('hidden', wmMode.value !== 'customDifferent');
});

wmRot.addEventListener('input', () => rotVal.textContent = wmRot.value);
wmOpacity.addEventListener('input', () => opVal.textContent = wmOpacity.value);
wmSize.addEventListener('input', () => sizeVal.textContent = wmSize.value);

/* Process button */
processBtn.addEventListener('click', async () => {
  if (!selectedBytes) return alert('Upload a PDF first.');
  processBtn.disabled = true;
  progressEl.textContent = 'Starting…';

  const mode = wmMode.value;
  const sameText = (customSame.value || '').trim();
  const diffLines = customDifferent.value.split(/\r?\n/).map(s => s.trim());
  const wmOptions = {
    position: wmPos.value,
    rotation: parseInt(wmRot.value,10) || 0,
    opacity: parseFloat(wmOpacity.value) || 0.45,
    baseSize: parseInt(wmSize.value,10) || 28,
    color: hexToRgb(wmColor.value)
  };

  try {
    progressEl.textContent = 'Imposing odd pages…';
    const oddPdfDoc = await createImposedPdf(selectedBytes, buildIndices(0), 'odd', mode, sameText, diffLines, wmOptions);
    progressEl.textContent = 'Imposing even pages…';
    const evenPdfDoc = await createImposedPdf(selectedBytes, buildIndices(1), 'even', mode, sameText, diffLines, wmOptions);

    progressEl.textContent = 'Saving files…';
    const oddBytes = await oddPdfDoc.save();
    const evenBytes = await evenPdfDoc.save();

    // setup downloads and previews
    setupDownload(oddDownload, oddBytes, `${safeName(fileName.textContent)}_odd.pdf`);
    setupDownload(evenDownload, evenBytes, `${safeName(fileName.textContent)}_even.pdf`);
    await renderPreview(oddBytes, oddPreview);
    await renderPreview(evenBytes, evenPreview);

    progressEl.textContent = 'Done.';
  } catch (err) {
    console.error(err);
    progressEl.textContent = `Error: ${err.message || err}`;
    alert('Processing error — check console for details.');
  } finally {
    processBtn.disabled = false;
  }
});

/* Helpers */
function buildIndices(startParity){
  // startParity 0 => odd pages (1,3,5) because page indexes 0-based
  // startParity 1 => even pages (2,4,6)
  const idx = [];
  // need page count: if unknown, attempt to load
  // selectedBytes should be present
  return (async ()=>{
    const doc = await PDFLib.PDFDocument.load(selectedBytes);
    const pc = doc.getPageCount();
    const arr = [];
    for (let i=0;i<pc;i++){
      if ((i % 2) === startParity) arr.push(i);
    }
    return arr;
  })();
}

/* create imposed PDF — accepts selectedBytes, but buildIndices returns a Promise, so wrapper handles */
async function createImposedPdf(originalBytes, pageIndicesPromiseOrArray, type, mode, sameText, diffLines, wmOptions){
  // pageIndices may be array or promise; normalize
  const pageIndices = Array.isArray(pageIndicesPromiseOrArray) ? pageIndicesPromiseOrArray : await pageIndicesPromiseOrArray;

  const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;
  const out = await PDFDocument.create();
  const A4_W = 595, A4_H = 842;
  const cols = 4, rows = 4, perSheet = cols * rows;
  const cellW = A4_W / cols, cellH = A4_H / rows;

  // embed font into THIS output PDF (must be embedded where drawText is used)
  const font = await out.embedFont(StandardFonts.HelveticaBold);

  // nothing to do
  if (!pageIndices || pageIndices.length===0) return out;

  // We'll embed pages in chunks using originalBytes and indexes (0-based)
  const sheets = Math.ceil(pageIndices.length / perSheet);

  for (let s=0; s<sheets; s++){
    const page = out.addPage([A4_W, A4_H]);
    const chunk = pageIndices.slice(s*perSheet, (s+1)*perSheet);
    // embedPdf expects bytes & pageIndexes; returns array of embedded page objects
    const embeddedPages = await out.embedPdf(originalBytes, chunk);

    for (let i=0;i<embeddedPages.length;i++){
      const emb = embeddedPages[i];
      const row = Math.floor(i / cols);
      const col = (type === 'odd') ? (i % cols) : (cols - 1 - (i % cols));
      const cellX = col * cellW;
      const cellY = A4_H - (row + 1) * cellH;

      // preserve aspect ratio and center within cell
      const eW = emb.width, eH = emb.height;
      const scale = Math.min(cellW / eW, cellH / eH);
      const drawW = eW * scale, drawH = eH * scale;
      const drawX = cellX + (cellW - drawW) / 2;
      const drawY = cellY + (cellH - drawH) / 2;

      // draw the embedded mini-page
      page.drawPage(emb, { x: drawX, y: drawY, width: drawW, height: drawH });

      // determine watermark text based on mode
      let text = '';
      if (mode === 'pageNumbers') {
        text = String(chunk[i] + 1); // original page number (1-based)
      } else if (mode === 'customSame') {
        text = sameText;
      } else if (mode === 'customDifferent') {
        // diffLines indexed by original page number starting at 1 -> index 0
        text = (diffLines && diffLines[chunk[i]]) ? diffLines[chunk[i]] : '';
      }

      if (text && text.trim() !== '') {
        // compute font size auto-fit so text never overflows mini-page
        const padding = Math.max(6, Math.min(12, Math.floor(Math.min(drawW, drawH) * 0.06)));
        const maxW = drawW - padding*2;
        const maxH = drawH - padding*2;
        // start with base size option and clamp
        let size = wmOptions.baseSize || 28;
        // limit by height first
        const maxByHeight = Math.floor(maxH * 0.55);
        if (size > maxByHeight) size = maxByHeight;
        // now reduce until width fits
        let textWidth = font.widthOfTextAtSize(text, size);
        while (textWidth > maxW && size > 6) {
          size = Math.floor(size * 0.9);
          textWidth = font.widthOfTextAtSize(text, size);
        }
        if (size < 6) size = 6;

        // position inside the mini-page area
        let tx = drawX + (drawW - textWidth) / 2;
        let ty = drawY + (drawH - size) / 2; // baseline at approx center

        switch (wmOptions.position) {
          case 'top-left':
            tx = drawX + padding;
            ty = drawY + drawH - size - padding;
            break;
          case 'top-right':
            tx = drawX + drawW - textWidth - padding;
            ty = drawY + drawH - size - padding;
            break;
          case 'bottom-left':
            tx = drawX + padding;
            ty = drawY + padding;
            break;
          case 'bottom-right':
            tx = drawX + drawW - textWidth - padding;
            ty = drawY + padding;
            break;
          case 'center':
          default:
            // already set center
            break;
        }

        // clamp into mini-page bounds
        if (tx < drawX + 2) tx = drawX + 2;
        if (ty < drawY + 2) ty = drawY + 2;

        // draw text with rotation, opacity, color
        page.drawText(text, {
          x: tx,
          y: ty,
          size: size,
          font: font,
          color: PDFLib.rgb(wmOptions.color.r, wmOptions.color.g, wmOptions.color.b),
          opacity: typeof wmOptions.opacity === 'number' ? wmOptions.opacity : 0.45,
          rotate: PDFLib.degrees(wmOptions.rotation || 0)
        });
      }
    }
  }

  return out;
}

/* Utility: hex -> rgb {r,g,b} normalized */
function hexToRgb(hex){
  const h = (hex||'#000000').replace('#','');
  const r = parseInt(h.substring(0,2)||'0',16)/255;
  const g = parseInt(h.substring(2,4)||'0',16)/255;
  const b = parseInt(h.substring(4,6)||'0',16)/255;
  return { r,g,b };
}

/* Setup download anchor from bytes */
function setupDownload(anchor, bytes, filename){
  const blob = new Blob([bytes], { type:'application/pdf' });
  const url = URL.createObjectURL(blob);
  anchor.href = url;
  anchor.download = filename;
  anchor.classList.remove('hidden');
}

/* small sanitizer for filenames */
function safeName(n){
  return (n||'document').replace(/\.[^/.]+$/, '').replace(/[^\w\-_. ]+/g,'').trim() || 'document';
}

/* Render preview using pdf.js */
async function renderPreview(pdfBytes, canvas){
  try {
    const loading = pdfjsLib.getDocument({ data: pdfBytes });
    const pdf = await loading.promise;
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 1.1 });
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
  } catch (err) {
    console.warn('Preview render failed:', err);
  }
}
</script>
</body>
</html>