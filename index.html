<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>16-up Odd/Even PDF Split & Layout</title>
<style>
  body { font-family: system-ui, -apple-system, Roboto, Arial; padding: 16px; max-width: 920px; margin: auto; }
  h1 { margin-top: 0; }
  label { display:block; margin:8px 0 4px; font-weight:600; }
  input, select, button, textarea { font-size:1rem; padding:8px; width:100%; box-sizing:border-box; }
  .row { display:flex; gap:12px; }
  .col { flex:1; }
  #preview { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; }
  .thumb { width:120px; height:170px; object-fit:cover; border:1px solid #ddd; background:#f8f8f8; }
  .controls { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .small { font-size:0.9rem; padding:6px; }
  .flex { display:flex; gap:8px; align-items:center; }
  footer { margin-top:18px; color:#666; font-size:0.9rem; }
</style>
</head>
<body>
<h1>16-up Odd/Even PDF â€” generator</h1>

<input id="fileInput" type="file" accept="application/pdf" />

<div style="margin-top:12px;">
  <label>Watermark (optional)</label>
  <input id="wmText" placeholder="Watermark text (leave blank for none)" />
  <div class="controls" style="margin-top:8px;">
    <div>
      <label>Position</label>
      <select id="wmPos">
        <option value="center">Center</option>
        <option value="top-left">Top-left</option>
        <option value="top-right">Top-right</option>
        <option value="bottom-left">Bottom-left</option>
        <option value="bottom-right">Bottom-right</option>
        <option value="bottom-center">Bottom-center</option>
        <option value="top-center">Top-center</option>
      </select>
    </div>
    <div>
      <label>Opacity (0.0 - 1.0)</label>
      <input id="wmOpacity" type="number" min="0" max="1" step="0.05" value="0.2" />
    </div>
    <div>
      <label>Rotation (deg)</label>
      <input id="wmRot" type="number" value="45" />
    </div>
    <div>
      <label>Font size</label>
      <input id="wmSize" type="number" value="36" />
    </div>
    <div>
      <label>Font color (hex)</label>
      <input id="wmColor" value="#B0B0B0" />
    </div>
    <div>
      <label>Apply watermark?</label>
      <select id="wmApply">
        <option value="yes">Yes</option>
        <option value="no">No</option>
      </select>
    </div>
  </div>
</div>

<div style="margin-top:12px;">
  <button id="generate" class="small">Generate PDFs (Odd & Even)</button>
</div>

<div id="progress" style="margin-top:12px; color:#333"></div>

<h3 style="margin-top:18px;">Preview (thumbnails)</h3>
<div id="preview"></div>

<div style="margin-top:12px;">
  <a id="downloadOdd" style="display:none" class="small" download="odd_16up.pdf">Download odd pages PDF</a>
  <a id="downloadEven" style="display:none; margin-left:12px" class="small" download="even_16up.pdf">Download even pages PDF</a>
</div>

<footer>
  Built for mobile & desktop browsers. For heavy PDFs use desktop Chrome.
</footer>

<!-- Libraries -->
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/pdfjs-dist/build/pdf.min.js"></script>

<script>
(async ()=> {
  const { PDFDocument, rgb, StandardFonts } = PDFLib;
  // pdfjs global: window['pdfjsLib']
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist/build/pdf.worker.min.js';

  const fileInput = document.getElementById('fileInput');
  const generateBtn = document.getElementById('generate');
  const progress = document.getElementById('progress');
  const preview = document.getElementById('preview');
  const downloadOdd = document.getElementById('downloadOdd');
  const downloadEven = document.getElementById('downloadEven');

  function setProgress(txt){ progress.textContent = txt; }

  async function readFileAsArrayBuffer(file){
    return await new Promise((res, rej)=>{
      const fr = new FileReader();
      fr.onload = ()=>res(fr.result);
      fr.onerror = ()=>rej(fr.error);
      fr.readAsArrayBuffer(file);
    });
  }

  // Render a single page to data URL (PNG)
  async function renderPageToImage(pdfDoc, pageIndex, scale=1.5){
    const page = await pdfDoc.getPage(pageIndex + 1);
    const viewport = page.getViewport({ scale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(viewport.width);
    canvas.height = Math.round(viewport.height);
    const ctx = canvas.getContext('2d');
    const renderCtx = { canvasContext: ctx, viewport };
    await page.render(renderCtx).promise;
    return canvas.toDataURL('image/png');
  }

  // Compute cell layout for 4x4 on A4 portrait
  function getGridSlots(pageWidth = 595.28, pageHeight = 841.89, margin = 16){
    // A4 in PDF points (approx 72dpi): 595.28 x 841.89
    const cols = 4, rows = 4;
    const usableW = pageWidth - margin * 2;
    const usableH = pageHeight - margin * 2;
    const cellW = usableW / cols;
    const cellH = usableH / rows;
    const slots = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = margin + c * cellW;
        const y = margin + r * cellH;
        // pdf-lib origin is bottom-left; we will convert when drawing
        slots.push({ x, y, w: cellW, h: cellH, row: r, col: c });
      }
    }
    return { slots, pageWidth, pageHeight };
  }

  // Even page fill order (so visual left->right rows show the pattern you described)
  const evenFillPositions = [3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12];

  // Compose a 16-up PDF from an array of image dataURLs with ordering according to a posMap.
  async function compose16Up(images /*array of dataURLs or nulls for blanks*/, posMap /*array length 16 -> indices in images or null for blank*/, watermark){
    const pdfDoc = await PDFDocument.create();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const { slots, pageWidth, pageHeight } = getGridSlots();
    const page = pdfDoc.addPage([pageWidth, pageHeight]);

    // We'll place images in fixed positions using posMap.
    // posMap[positionIndex] = index into images array OR null
    for(let positionIndex = 0; positionIndex < 16; positionIndex++){
      const imgIndex = posMap[positionIndex];
      if (imgIndex == null || imgIndex >= images.length) continue;
      const dataUrl = images[imgIndex];
      if (!dataUrl) continue;
      // embed image
      const pngBytes = dataUrl.split(',')[1];
      const img = await pdfDoc.embedPng(dataUrl);
      const slot = slots[positionIndex];
      // pdf-lib y origin is bottom-left, slot.y was from top-left style; convert:
      const drawX = slot.x;
      const drawY = pageHeight - slot.y - slot.h;
      // Calculate fitting with aspect ratio preserved
      const iw = img.width, ih = img.height;
      const scale = Math.min(slot.w / iw, slot.h / ih);
      const dw = iw * scale, dh = ih * scale;
      // center inside the cell
      const dx = drawX + (slot.w - dw) / 2;
      const dy = drawY + (slot.h - dh) / 2;
      page.drawImage(img, { x: dx, y: dy, width: dw, height: dh });
    }

    // Watermark
    if (watermark && watermark.apply && watermark.text.trim() !== ''){
      const t = watermark.text;
      const fontSize = watermark.fontSize || 36;
      const opacity = Number(watermark.opacity) || 0.2;
      const angle = (Number(watermark.rotation)||0) * Math.PI / 180;
      const color = watermark.color || '#B0B0B0';
      // place according to position
      // compute text width/height
      const textWidth = font.widthOfTextAtSize(t, fontSize);
      const textHeight = fontSize;
      // default position center
      let x = pageWidth/2 - textWidth/2;
      let y = pageHeight/2 - textHeight/2;
      switch(watermark.position){
        case 'top-left': x = 32; y = pageHeight - 32 - textHeight; break;
        case 'top-right': x = pageWidth - 32 - textWidth; y = pageHeight - 32 - textHeight; break;
        case 'bottom-left': x = 32; y = 32; break;
        case 'bottom-right': x = pageWidth - 32 - textWidth; y = 32; break;
        case 'bottom-center': x = pageWidth/2 - textWidth/2; y = 32; break;
        case 'top-center': x = pageWidth/2 - textWidth/2; y = pageHeight - 32 - textHeight; break;
        default: x = pageWidth/2 - textWidth/2; y = pageHeight/2 - textHeight/2;
      }
      // draw rotated text on every page (only one page currently added per compose call)
      page.drawText(t, {
        x, y, size: fontSize, font,
        color: rgb(...hexToRgbNormalized(color)),
        rotate: angle,
        opacity
      });
    }

    return await pdfDoc.save();
  }

  function hexToRgbNormalized(hex){
    hex = hex.replace('#','');
    if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
    const r = parseInt(hex.substring(0,2),16)/255;
    const g = parseInt(hex.substring(2,4),16)/255;
    const b = parseInt(hex.substring(4,6),16)/255;
    return [r,g,b];
  }

  // Top-level: take images array and produce array of page-bytes for sheet pages based on ordering function
  async function buildSheetsFromImages(images, ordering /*function that returns posMap for each sheet*/, watermark){
    const sheets = [];
    // chunk images into blocks of 16 mapped to sheet positions by ordering
    // But ordering expects we provide images in ascending page order and returns the mapping for positions (posMap)
    let processed = 0;
    while(processed < images.length){
      // take up to 16 image references as a slice for this "logical block"
      const block = images.slice(processed, processed + 16);
      // For odd layout, ordering is trivial (pos 0..15 map to indices 0..15)
      // For even layout we use evenFillPositions mapping: positions array length 16 where pos -> index into block or null
      const posMap = new Array(16).fill(null);
      const blockSize = block.length;
      // call ordering function that fills posMap using global evenFillPositions if needed
      ordering(posMap, processed, images.length, blockSize);
      // we need images array index references for posMap: ordering should set posMap[position] = globalIndex or null
      // But compose16Up expects posMap indices relative to images array passed in; easier: create per-sheet images array and a per-sheet pos map where index maps to index in per-sheet images array
      // We'll build per-sheet images array from the global images indices present in posMap:
      const perSheetImages = [];
      const perSheetMap = new Array(16).fill(null);
      // gather unique global indices in posMap in ascending order of when they appear in posMap
      const mappingFromGlobalToLocal = {};
      let localIdx = 0;
      for(let p=0;p<16;p++){
        const gidx = posMap[p];
        if (gidx==null) continue;
        if (gidx < processed || gidx >= processed + 16){
          // if ordering used global indices outside this block, map accordingly
        }
        if (!(gidx in mappingFromGlobalToLocal)){
          mappingFromGlobalToLocal[gidx] = localIdx++;
          perSheetImages.push(images[gidx]);
        }
        perSheetMap[p] = mappingFromGlobalToLocal[gidx];
      }
      // produce the sheet bytes
      const bytes = await compose16Up(perSheetImages, perSheetMap, watermark);
      sheets.push(bytes);
      processed += 16;
    }
    return sheets;
  }

  // But simpler: Instead of trying to map global indices across blocks, we will create sheets by repeatedly taking next up to 16 source images (in order),
  // and for each sheet compute posMapPositions relative to that slice using the specific fillOrder for even pages.
  // Re-implement sheet build functions separately for odd and even using this simpler approach.

  async function buildSheetsSimple(images /*global images array*/, fillType /*'odd'|'even'*/, watermark){
    const sheetsBytes = [];
    const pageChunkSize = 16;
    for(let offset = 0; offset < images.length; offset += pageChunkSize){
      const slice = images.slice(offset, offset + pageChunkSize); // length <= 16
      // posMap where posMap[position] = index in slice (0..slice.length-1) or null
      const posMap = new Array(16).fill(null);
      if (fillType === 'odd'){
        // fill left->right top->bottom: pos 0..(slice.length-1) = 0..n-1
        for(let i=0;i<slice.length;i++){
          posMap[i] = i;
        }
      } else {
        // even: use evenFillPositions to map ascending slice indices into positions
        // evenFillPositions array defines positions in the page that will be filled in ascending order of pages
        for(let i=0;i<slice.length;i++){
          const pos = evenFillPositions[i];
          posMap[pos] = i;
        }
      }
      const b = await compose16Up(slice, posMap, watermark);
      sheetsBytes.push(b);
    }
    return sheetsBytes;
  }

  // Merge sheet bytes into single PDF
  async function mergeSheets(sheetByteArrays){
    // if only one sheet, return it
    if (sheetByteArrays.length === 1) return sheetByteArrays[0];
    const out = await PDFDocument.create();
    for(const bytes of sheetByteArrays){
      const src = await PDFDocument.load(bytes);
      const copied = await out.copyPages(src, src.getPageIndices());
      for(const p of copied) out.addPage(p);
    }
    return await out.save();
  }

  // Preview helper createThumb (takes first sheet byte and renders first page)
  async function createPreviewFromPdfBytes(bytes){
    // load with pdfjs from bytes -> url
    const uint8 = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
    const loadingTask = pdfjsLib.getDocument({ data: uint8 });
    const doc = await loadingTask.promise;
    const page = await doc.getPage(1);
    const vp = page.getViewport({ scale: 0.5 });
    const c = document.createElement('canvas');
    c.width = vp.width; c.height = vp.height;
    const ctx = c.getContext('2d');
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    return c.toDataURL('image/png');
  }

  // Generate logic
  generateBtn.addEventListener('click', async ()=>{
    const file = fileInput.files && fileInput.files[0];
    if (!file){ alert('Choose a PDF file first'); return; }
    setProgress('Reading file...');
    downloadOdd.style.display = 'none'; downloadEven.style.display = 'none';
    preview.innerHTML = '';

    const arrayBuffer = await readFileAsArrayBuffer(file);
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    setProgress('Loading PDF in renderer...');
    const pdfDoc = await loadingTask.promise;
    const pageCount = pdfDoc.numPages;
    setProgress(`PDF loaded â€” ${pageCount} pages. Rendering pages to images... (this may take a bit)`);

    // render each page to dataURL (sequential to avoid memory spikes)
    const pageImages = [];
    for(let i=0;i<pageCount;i++){
      setProgress(`Rendering page ${i+1}/${pageCount}...`);
      const dataUrl = await renderPageToImage(pdfDoc, i, 1.6); // scale tweaking: 1.6 works reasonably
      pageImages.push(dataUrl);
      // quick thumbnail preview of original pages (can be heavy if many; we only show a few)
      if (i < 6){
        const img = document.createElement('img'); img.src = dataUrl; img.className='thumb';
        preview.appendChild(img);
      }
    }

    // separate odd/even pages per user's definition: odd pages are 1,3,5 -> indices 0,2,4; even are 2,4,6 -> indices 1,3,5
    const oddImages = [];
    const evenImages = [];
    for(let i=0;i<pageImages.length;i++){
      const pageNumber = i+1;
      if (pageNumber % 2 === 1) oddImages.push(pageImages[i]);
      else evenImages.push(pageImages[i]);
    }

    // watermark object
    const watermark = {
      apply: (document.getElementById('wmApply').value === 'yes'),
      text: document.getElementById('wmText').value || '',
      position: document.getElementById('wmPos').value,
      opacity: Number(document.getElementById('wmOpacity').value),
      rotation: Number(document.getElementById('wmRot').value),
      fontSize: Number(document.getElementById('wmSize').value),
      color: document.getElementById('wmColor').value
    };

    // Build odd sheets
    setProgress('Composing odd-pages sheets (16-up Lâ†’R, topâ†’bottom)...');
    const oddSheets = await buildSheetsSimple(oddImages, 'odd', watermark);
    setProgress('Merging odd sheets...');
    const oddBytes = await mergeSheets(oddSheets);

    // Build even sheets
    setProgress('Composing even-pages sheets (custom rightâ†’left block layout)...');
    const evenSheets = await buildSheetsSimple(evenImages, 'even', watermark);
    setProgress('Merging even sheets...');
    const evenBytes = await mergeSheets(evenSheets);

    setProgress('Generating downloadable files and preview...');
    // create blob URLs for download
    const oddBlob = new Blob([oddBytes], { type: 'application/pdf' });
    const evenBlob = new Blob([evenBytes], { type: 'application/pdf' });
    const oddUrl = URL.createObjectURL(oddBlob);
    const evenUrl = URL.createObjectURL(evenBlob);
    downloadOdd.href = oddUrl; downloadOdd.style.display='inline-block';
    downloadEven.href = evenUrl; downloadEven.style.display='inline-block';

    // add previews (first page thumbnails)
    try{
      const oddPreviewData = await createPreviewFromPdfBytes(oddBytes);
      const evenPreviewData = await createPreviewFromPdfBytes(evenBytes);
      const imgOdd = document.createElement('img'); imgOdd.src = oddPreviewData; imgOdd.className='thumb';
      const imgEven = document.createElement('img'); imgEven.src = evenPreviewData; imgEven.className='thumb';
      const holder = document.createElement('div'); holder.style.display='flex'; holder.style.gap='8px';
      holder.appendChild(imgOdd); holder.appendChild(imgEven);
      preview.appendChild(holder);
    } catch(e){
      console.warn('Preview generation failed', e);
    }

    setProgress('Done. Click download links above.');
  });

})();
</script>
</body>
</html>

