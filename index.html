<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>16-up Odd/Even PDF Split & Layout</title>
<style>
  body { font-family: system-ui, -apple-system, Roboto, Arial; padding: 16px; max-width: 920px; margin: auto; }
  h1 { margin-top: 0; }
  label { display:block; margin:8px 0 4px; font-weight:600; }
  input, select, button, textarea { font-size:1rem; padding:8px; width:100%; box-sizing:border-box; }
  .row { display:flex; gap:12px; }
  .col { flex:1; }
  #preview { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; }
  .thumb { width:120px; height:170px; object-fit:cover; border:1px solid #ddd; background:#f8f8f8; }
  .controls { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .small { font-size:0.9rem; padding:6px; }
  .flex { display:flex; gap:8px; align-items:center; }
  footer { margin-top:18px; color:#666; font-size:0.9rem; }
</style>
</head>
<body>
<h1>16-up Odd/Even PDF — generator</h1>

<p style="margin-top:12px;">This tool splits your PDF into odd & even pages, then lays them out 16-up on new sheets. Each thumbnail is automatically watermarked with its original page number.</p>

<input id="fileInput" type="file" accept="application/pdf" style="margin-top:12px;" />


<div style="margin-top:12px;">
  <button id="generate">Generate PDFs (Odd & Even)</button>
</div>

<div id="progress" style="margin-top:12px; color:#333"></div>

<h3 style="margin-top:18px;">Preview (thumbnails)</h3>
<div id="preview"></div>

<div style="margin-top:12px;">
  <a id="downloadOdd" style="display:none" class="small" download="odd_16up.pdf">Download odd pages PDF</a>
  <a id="downloadEven" style="display:none; margin-left:12px" class="small" download="even_16up.pdf">Download even pages PDF</a>
</div>

<footer>
  Built for mobile & desktop browsers. For heavy PDFs use desktop Chrome.
</footer>

<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/pdfjs-dist/build/pdf.min.js"></script>

<script>
(async ()=> {
  const { PDFDocument, rgb, StandardFonts } = PDFLib;
  // pdfjs global: window['pdfjsLib']
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist/build/pdf.worker.min.js';

  const fileInput = document.getElementById('fileInput');
  const generateBtn = document.getElementById('generate');
  const progress = document.getElementById('progress');
  const preview = document.getElementById('preview');
  const downloadOdd = document.getElementById('downloadOdd');
  const downloadEven = document.getElementById('downloadEven');

  function setProgress(txt){ progress.textContent = txt; }

  async function readFileAsArrayBuffer(file){
    return await new Promise((res, rej)=>{
      const fr = new FileReader();
      fr.onload = ()=>res(fr.result);
      fr.onerror = ()=>rej(fr.error);
      fr.readAsArrayBuffer(file);
    });
  }

  // Render a single page to data URL (PNG)
  async function renderPageToImage(pdfDoc, pageIndex, scale=1.5){
    const page = await pdfDoc.getPage(pageIndex + 1);
    const viewport = page.getViewport({ scale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(viewport.width);
    canvas.height = Math.round(viewport.height);
    const ctx = canvas.getContext('2d');
    const renderCtx = { canvasContext: ctx, viewport };
    await page.render(renderCtx).promise;
    return canvas.toDataURL('image/png');
  }

  // Compute cell layout for 4x4 on A4 portrait
  function getGridSlots(pageWidth = 595.28, pageHeight = 841.89, margin = 16){
    // A4 in PDF points (approx 72dpi): 595.28 x 841.89
    const cols = 4, rows = 4;
    const usableW = pageWidth - margin * 2;
    const usableH = pageHeight - margin * 2;
    const cellW = usableW / cols;
    const cellH = usableH / rows;
    const slots = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = margin + c * cellW;
        const y = margin + r * cellH;
        slots.push({ x, y, w: cellW, h: cellH, row: r, col: c });
      }
    }
    return { slots, pageWidth, pageHeight };
  }

  // Even page fill order (right-to-left rows)
  const evenFillPositions = [3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12];

  // Compose a 16-up PDF from an array of page objects with individual watermarks.
  async function compose16Up(pageObjects /*array of {pageNumber, dataUrl}*/, posMap /*array length 16 -> indices in pageObjects or null for blank*/){
    const pdfDoc = await PDFDocument.create();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const { slots, pageWidth, pageHeight } = getGridSlots();
    const page = pdfDoc.addPage([pageWidth, pageHeight]);

    // We'll place images in fixed positions using posMap.
    for(let positionIndex = 0; positionIndex < 16; positionIndex++){
      const objIndex = posMap[positionIndex];
      if (objIndex == null || objIndex >= pageObjects.length) continue;
      
      const pageObject = pageObjects[objIndex];
      if (!pageObject || !pageObject.dataUrl) continue;
      
      // Embed image
      const img = await pdfDoc.embedPng(pageObject.dataUrl);
      const slot = slots[positionIndex];
      
      // pdf-lib y origin is bottom-left, slot.y was from top-left style; convert:
      const drawX = slot.x;
      const drawY = pageHeight - slot.y - slot.h;
      
      // Calculate fitting with aspect ratio preserved
      const scale = Math.min(slot.w / img.width, slot.h / img.height);
      const dw = img.width * scale;
      const dh = img.height * scale;
      
      // Center inside the cell
      const dx = drawX + (slot.w - dw) / 2;
      const dy = drawY + (slot.h - dh) / 2;
      page.drawImage(img, { x: dx, y: dy, width: dw, height: dh });

      // ** NEW: Add individual watermark with original page number **
      const watermarkText = String(pageObject.pageNumber);
      const watermarkFontSize = 14;
      const textWidth = font.widthOfTextAtSize(watermarkText, watermarkFontSize);
      const textHeight = font.getCapHeightAtSize(watermarkFontSize);

      // Center the text within the drawn image bounds (dx, dy, dw, dh)
      const textX = dx + (dw - textWidth) / 2;
      const textY = dy + (dh - textHeight) / 2;

      page.drawText(watermarkText, {
          x: textX,
          y: textY,
          size: watermarkFontSize,
          font,
          color: rgb(0.5, 0.5, 0.5), // Gray color
          opacity: 0.6
      });
    }

    return await pdfDoc.save();
  }

  // Build sheets (pages of the new PDF) from an array of page objects
  async function buildSheetsSimple(pageObjects /*global pageObjects array*/, fillType /*'odd'|'even'*/){
    const sheetsBytes = [];
    const pageChunkSize = 16;
    for(let offset = 0; offset < pageObjects.length; offset += pageChunkSize){
      const slice = pageObjects.slice(offset, offset + pageChunkSize); // length <= 16
      
      // posMap where posMap[position] = index in slice (0..slice.length-1) or null
      const posMap = new Array(16).fill(null);
      if (fillType === 'odd'){
        // Fill left->right top->bottom: pos 0..(slice.length-1) = 0..n-1
        for(let i=0; i<slice.length; i++){
          posMap[i] = i;
        }
      } else {
        // Even: use evenFillPositions to map ascending slice indices into positions
        for(let i=0; i<slice.length; i++){
          const pos = evenFillPositions[i];
          posMap[pos] = i;
        }
      }
      const b = await compose16Up(slice, posMap);
      sheetsBytes.push(b);
    }
    return sheetsBytes;
  }

  // Merge sheet bytes into a single PDF
  async function mergeSheets(sheetByteArrays){
    if (sheetByteArrays.length === 0) return new Uint8Array();
    if (sheetByteArrays.length === 1) return sheetByteArrays[0];
    
    const out = await PDFDocument.create();
    for(const bytes of sheetByteArrays){
      const src = await PDFDocument.load(bytes);
      const [copiedPage] = await out.copyPages(src, [0]);
      out.addPage(copiedPage);
    }
    return await out.save();
  }

  // Preview helper to create a thumbnail from the first sheet's bytes
  async function createPreviewFromPdfBytes(bytes){
    if (!bytes || bytes.length === 0) return null;
    const uint8 = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
    const loadingTask = pdfjsLib.getDocument({ data: uint8 });
    const doc = await loadingTask.promise;
    const page = await doc.getPage(1);
    const vp = page.getViewport({ scale: 0.5 });
    const c = document.createElement('canvas');
    c.width = vp.width; c.height = vp.height;
    const ctx = c.getContext('2d');
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    return c.toDataURL('image/png');
  }

  // --- Main Generate Logic ---
  generateBtn.addEventListener('click', async ()=>{
    const file = fileInput.files && fileInput.files[0];
    if (!file){ alert('Choose a PDF file first'); return; }
    setProgress('Reading file...');
    downloadOdd.style.display = 'none'; downloadEven.style.display = 'none';
    preview.innerHTML = '';

    const arrayBuffer = await readFileAsArrayBuffer(file);
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    setProgress('Loading PDF in renderer...');
    const pdfDoc = await loadingTask.promise;
    const pageCount = pdfDoc.numPages;
    setProgress(`PDF loaded — ${pageCount} pages. Rendering pages to images... (this may take a bit)`);

    // Render each page to a dataURL and store it with its original page number.
    const allPageObjects = [];
    for(let i=0; i<pageCount; i++){
      const pageNumber = i + 1;
      setProgress(`Rendering page ${pageNumber}/${pageCount}...`);
      const dataUrl = await renderPageToImage(pdfDoc, i, 1.6);
      allPageObjects.push({ pageNumber, dataUrl });
      
      // Quick thumbnail preview of original pages
      if (i < 6){
        const img = document.createElement('img'); img.src = dataUrl; img.className='thumb';
        preview.appendChild(img);
      }
    }

    // Separate into odd/even page objects
    const oddPageObjects = [];
    const evenPageObjects = [];
    for(const pageObj of allPageObjects){
      if (pageObj.pageNumber % 2 === 1) {
        oddPageObjects.push(pageObj);
      } else {
        evenPageObjects.push(pageObj);
      }
    }

    // Build odd sheets
    setProgress('Composing odd-pages sheets (16-up L→R, top→bottom)...');
    const oddSheets = await buildSheetsSimple(oddPageObjects, 'odd');
    setProgress('Merging odd sheets...');
    const oddBytes = await mergeSheets(oddSheets);

    // Build even sheets
    setProgress('Composing even-pages sheets (custom right→left block layout)...');
    const evenSheets = await buildSheetsSimple(evenPageObjects, 'even');
    setProgress('Merging even sheets...');
    const evenBytes = await mergeSheets(evenSheets);

    setProgress('Generating downloadable files and preview...');
    
    // Create blob URLs for download for odd pages
    if(oddBytes.length > 0) {
      const oddBlob = new Blob([oddBytes], { type: 'application/pdf' });
      const oddUrl = URL.createObjectURL(oddBlob);
      downloadOdd.href = oddUrl;
      downloadOdd.style.display='inline-block';
    } else {
      downloadOdd.style.display='none';
    }

    // Create blob URLs for download for even pages
    if(evenBytes.length > 0) {
      const evenBlob = new Blob([evenBytes], { type: 'application/pdf' });
      const evenUrl = URL.createObjectURL(evenBlob);
      downloadEven.href = evenUrl;
      downloadEven.style.display='inline-block';
    } else {
      downloadEven.style.display='none';
    }

    // Add previews of the final generated PDFs
    try {
        const oddPreviewData = await createPreviewFromPdfBytes(oddBytes);
        const evenPreviewData = await createPreviewFromPdfBytes(evenBytes);
        const holder = document.createElement('div');
        holder.style.display='flex';
        holder.style.gap='8px';
        holder.style.marginTop='16px';
        
        const existingHolder = document.getElementById('preview-holder');
        if(existingHolder) existingHolder.remove();
        holder.id = 'preview-holder';

        if (oddPreviewData || evenPreviewData) {
            holder.innerHTML = `<strong style="width:100%; margin-bottom:4px;">Generated PDF Previews:</strong>`;
        }

        if (oddPreviewData) {
            const imgOdd = document.createElement('img');
            imgOdd.src = oddPreviewData;
            imgOdd.className = 'thumb';
            holder.appendChild(imgOdd);
        }
        if (evenPreviewData) {
            const imgEven = document.createElement('img');
            imgEven.src = evenPreviewData;
            imgEven.className = 'thumb';
            holder.appendChild(imgEven);
        }
        if(holder.children.length > 1) { // more than just the strong tag
            preview.appendChild(holder);
        }
    } catch(e){
      console.warn('Preview generation failed', e);
    }

    setProgress('Done. Click the download links that have appeared above.');
  });

})();
</script>
</body>
</html>
