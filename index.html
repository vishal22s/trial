<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PDF 16-up with Watermark Options</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .upload-box { border: 2px dashed #888; padding: 20px; text-align: center; cursor: pointer; margin-bottom: 20px; }
    .output-box { margin-top: 20px; }
</style>
</head>
<body>

<h2>PDF 16-up with Advanced Watermark</h2>

<div class="upload-box" id="upload-box">
    Click or drop PDF here to upload
    <input type="file" id="pdf-upload" accept="application/pdf" style="display:none;">
</div>

<div>
    <label>Watermark Mode:</label>
    <select id="watermark-mode">
        <option value="pageNumbers">Page Numbers</option>
        <option value="customSame">Custom Text (Same for All)</option>
        <option value="customDifferent">Custom Text (Different for Each)</option>
    </select>
</div>

<div id="custom-same-box" style="display:none; margin-top:10px;">
    <label>Custom Text:</label>
    <input type="text" id="custom-same-text" placeholder="Enter watermark text">
</div>

<div id="custom-different-box" style="display:none; margin-top:10px;">
    <label>Custom Texts (one per page, line by line):</label><br>
    <textarea id="custom-different-texts" rows="6" style="width:100%;" placeholder="Line 1 → Page 1&#10;Line 2 → Page 2"></textarea>
</div>

<button id="process-btn" style="margin-top:20px;">Process PDF</button>

<div class="output-box">
    <h3>Odd Pages Output:</h3>
    <canvas id="odd-preview" style="border:1px solid #ccc;"></canvas>
    <a id="odd-download" download="">Download Odd Pages PDF</a>
</div>

<div class="output-box">
    <h3>Even Pages Output:</h3>
    <canvas id="even-preview" style="border:1px solid #ccc;"></canvas>
    <a id="even-download" download="">Download Even Pages PDF</a>
</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js";

document.getElementById('upload-box').addEventListener('click', () => {
    document.getElementById('pdf-upload').click();
});

document.getElementById('upload-box').addEventListener('dragover', e => {
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'copy';
});

document.getElementById('upload-box').addEventListener('drop', e => {
    e.preventDefault();
    e.stopPropagation();
    document.getElementById('pdf-upload').files = e.dataTransfer.files;
});

document.getElementById('watermark-mode').addEventListener('change', function(){
    document.getElementById('custom-same-box').style.display = (this.value === 'customSame') ? 'block' : 'none';
    document.getElementById('custom-different-box').style.display = (this.value === 'customDifferent') ? 'block' : 'none';
});

document.getElementById('process-btn').addEventListener('click', async () => {
    const fileInput = document.getElementById('pdf-upload');
    if (!fileInput.files.length) return alert('Please upload a PDF first.');

    const pdfBytes = await fileInput.files[0].arrayBuffer();
    const mode = document.getElementById('watermark-mode').value;
    let customSameText = document.getElementById('custom-same-text').value || '';
    let customDifferentTexts = document.getElementById('custom-different-texts').value.split('\n');

    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
    const totalPages = pdfDoc.getPageCount();
    const oddPages = [], evenPages = [];

    for (let i = 0; i < totalPages; i++) {
        (i % 2 === 0 ? oddPages : evenPages).push(i);
    }

    const oddPdfBytes = await createImposedPdf(pdfDoc, oddPages, mode, customSameText, customDifferentTexts);
    const evenPdfBytes = await createImposedPdf(pdfDoc, evenPages, mode, customSameText, customDifferentTexts, true);

    document.getElementById('odd-download').href = URL.createObjectURL(new Blob([oddPdfBytes], {type: 'application/pdf'}));
    document.getElementById('odd-download').download = "odd-pages.pdf";
    renderPreview(oddPdfBytes, document.getElementById('odd-preview'));

    document.getElementById('even-download').href = URL.createObjectURL(new Blob([evenPdfBytes], {type: 'application/pdf'}));
    document.getElementById('even-download').download = "even-pages.pdf";
    renderPreview(evenPdfBytes, document.getElementById('even-preview'));
});

async function createImposedPdf(srcPdfDoc, pageIndexes, mode, customSameText, customDifferentTexts, reverseOrder = false) {
    const { width, height } = PDFLib.PageSizes.A4;
    const imposedPdf = await PDFLib.PDFDocument.create();
    const helveticaFont = await imposedPdf.embedFont(PDFLib.StandardFonts.HelveticaBold);

    const pagesPerSheet = 16, cols = 4, rows = 4;
    const cellWidth = width / cols, cellHeight = height / rows;

    for (let i = 0; i < pageIndexes.length; i += pagesPerSheet) {
        const sheet = imposedPdf.addPage([width, height]);
        const chunk = pageIndexes.slice(i, i + pagesPerSheet);
        const embeddedPages = await imposedPdf.embedPages(chunk.map(idx => srcPdfDoc.getPage(idx)));

        chunk.forEach((pageIdx, j) => {
            const row = Math.floor(j / cols);
            let col = j % cols;
            if (reverseOrder) col = cols - 1 - col;

            const x = col * cellWidth;
            const y = height - (row + 1) * cellHeight;

            const epage = embeddedPages[j];
            const scale = Math.min(cellWidth / epage.width, cellHeight / epage.height);
            const scaledW = epage.width * scale;
            const scaledH = epage.height * scale;

            sheet.drawPage(epage, {
                x: x + (cellWidth - scaledW) / 2,
                y: y + (cellHeight - scaledH) / 2,
                width: scaledW,
                height: scaledH
            });

            // Determine watermark text
            let text = '';
            if (mode === 'pageNumbers') {
                text = (pageIdx + 1).toString();
            } else if (mode === 'customSame') {
                text = customSameText;
            } else if (mode === 'customDifferent') {
                text = customDifferentTexts[pageIdx] || '';
            }

            if (text) {
                const fontSize = Math.min(12, cellWidth / (text.length * 0.6));
                sheet.drawText(text, {
                    x: x + cellWidth / 2 - (helveticaFont.widthOfTextAtSize(text, fontSize) / 2),
                    y: y + cellHeight / 2 - fontSize / 2,
                    size: fontSize,
                    font: helveticaFont,
                    color: PDFLib.rgb(0.7, 0.7, 0.7),
                    opacity: 0.5
                });
            }
        });
    }
    return await imposedPdf.save();
}

async function renderPreview(pdfBytes, canvasElement) {
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 1 });
    const context = canvasElement.getContext('2d');
    canvasElement.height = viewport.height;
    canvasElement.width = viewport.width;
    await page.render({ canvasContext: context, viewport }).promise;
}
</script>

</body>
</html>